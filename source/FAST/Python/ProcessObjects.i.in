// Python process object functionality using directors feature

%feature("director") PythonProcessObject;
%shared_ptr(fast::PythonProcessObject)
%feature("director") PythonStreamer;
%shared_ptr(fast::PythonStreamer)
%feature("director") PythonRandomAccessStreamer;
%shared_ptr(fast::PythonRandomAccessStreamer)

%template(setBufferArg) fast::Kernel::setArg<fast::OpenCLBuffer>;
%template(setIntArg) fast::Kernel::setArg<int>;
%template(setShortArg) fast::Kernel::setArg<short>;
%template(setCharArg) fast::Kernel::setArg<char>;
%template(setUIntArg) fast::Kernel::setArg<uint>;
%template(setUShortArg) fast::Kernel::setArg<ushort>;
%template(setUCharArg) fast::Kernel::setArg<uchar>;
%template(setFloatArg) fast::Kernel::setArg<float>;

%template(setIntArgData) fast::Kernel::setArgData<int>;
%template(setShortArgData) fast::Kernel::setArgData<short>;
%template(setCharArgData) fast::Kernel::setArgData<char>;
%template(setUIntArgData) fast::Kernel::setArgData<uint>;
%template(setUShortArgData) fast::Kernel::setArgData<ushort>;
%template(setUCharArgData) fast::Kernel::setArgData<uchar>;
%template(setFloatArgData) fast::Kernel::setArgData<float>;

%feature("shadow") fast::PythonProcessObject::getQueue(fast::OpenCLDevice::pointer device) %{
def getQueue(self, device: "fast::OpenCLDevice::pointer"=None) -> "fast::Queue":
    return _fast.PythonProcessObject_getQueue(self, device)
%}

%inline %{

    namespace fast {
        class PythonProcessObject : public ProcessObject {
            public:
            virtual void execute() = 0;
            std::string getNameOfClass() const {
                return "PythonProcessObject";
            }
            virtual ~PythonProcessObject() { };
            std::shared_ptr<PythonProcessObject> m_hack;
            PythonProcessObject() {
                // A hack to make this work as PythonProcessObject does not return a smart pointer in create as other POs.
                // Use a custom deleter which doesn't delete to avoid double delete
                m_hack.reset(this, [](PythonProcessObject* obj) {});
                mPtr = m_hack;
            }

            void setInputConnection(DataChannel::pointer port) {
                ProcessObject::setInputConnection(0, port);
            }

            void setInputConnection(uint portID, DataChannel::pointer port) {
                ProcessObject::setInputConnection(portID, port);
            }

            void setInputData(DataObject::pointer data) {
                ProcessObject::setInputData(0, data);
            }

            void setInputData(uint portID, DataObject::pointer data) {
                ProcessObject::setInputData(portID, data);
            }

            DataChannel::pointer getOutputPort(uint portID = 0) {
                return ProcessObject::getOutputPort(portID);
            }

            void addOutputData(int port, std::shared_ptr<DataObject> image) {
                ProcessObject::addOutputData(port, image);
            }

            DataObject::pointer _getInputData(int port = 0) {
                auto data = ProcessObject::getInputData<DataObject>(port);
                return data;
            }

            void createInputPort(int port) {
                ProcessObject::createInputPort<DataObject>(port);
            }
            void createOutputPort(int port) {
                ProcessObject::createOutputPort<DataObject>(port);
            }

            virtual void stopPipeline() override {
                ProcessObject::stopPipeline();
            }

            using ProcessObject::getKernel;
            using ProcessObject::createInlineOpenCLProgram;
            using ProcessObject::createOpenCLProgram;
            using ProcessObject::getQueue;

            OpenCLBuffer createBuffer(
                    std::size_t size,
                    KernelMemoryAccess kernelAccess = KernelMemoryAccess::READ_WRITE,
                    HostMemoryAccess hostAccess = HostMemoryAccess::UNSPECIFIED,
                    OpenCLDevice::pointer device = nullptr
            ) const {
                return ProcessObject::createBuffer(size, kernelAccess, hostAccess, device);
            }
            template <class T>
            OpenCLBuffer createBuffer(
                    const std::vector<T>& data,
                    KernelMemoryAccess kernelAccess = KernelMemoryAccess::READ_WRITE,
                    HostMemoryAccess hostAccess = HostMemoryAccess::UNSPECIFIED,
                    OpenCLDevice::pointer device = nullptr
            ) const {
                return ProcessObject::createBuffer<T>(data, kernelAccess, hostAccess, device);
            }

            // Cant use 'using' here due to shadow
            Queue getQueue(fast::OpenCLDevice::pointer device = nullptr) {
                return ProcessObject::getQueue(device);
            }

        }; // end class python process object

        class PythonStreamer : public Streamer {
            public:
            virtual void generateStream() = 0;
            std::string getNameOfClass() const override {
                return "PythonStreamer";
            }
            void execute() {
                startStream();
                waitForFirstFrame();
            }
            virtual ~PythonStreamer() { };
            std::shared_ptr<PythonStreamer> m_hack;
            PythonStreamer() {
                // A hack to make this work as PythonStreamer does not return a smart pointer thread New as other POs.
                // Use a custom deleter which doesn't delete to avoid double delete
                m_hack.reset(this, [](PythonStreamer* obj) {});
                mPtr = m_hack;
                setModified(true);
            }

            bool isStopped() {
                return Streamer::isStopped();
            }

            void stop() {
                Streamer::stop();
            }

            void addOutputData(int port, std::shared_ptr<DataObject> image) {
                ProcessObject::addOutputData(port, image);
            }

            DataObject::pointer _getInputData(int port = 0) {
                auto data = ProcessObject::getInputData<DataObject>(port);
                return data;
            }

            DataChannel::pointer getOutputPort(uint portID = 0) {
                return ProcessObject::getOutputPort(portID);
            }

            void createInputPort(int port) {
                ProcessObject::createInputPort<DataObject>(port);
            }
            void createOutputPort(int port) {
                ProcessObject::createOutputPort<DataObject>(port);
            }
            void frameAdded() {
                Streamer::frameAdded();
            }
            virtual void stopPipeline() override {
                Streamer::stopPipeline();
            }
        }; // end class python streamer


        class PythonRandomAccessStreamer : public RandomAccessStreamer {
            public:
            virtual void generateStream() = 0;
            virtual int getNrOfFrames() = 0;
            std::string getNameOfClass() const {
                return "PythonRandomAccessStreamer";
            }
            void execute() {
                startStream();
                waitForFirstFrame();
            }
            virtual ~PythonRandomAccessStreamer() { };
            std::shared_ptr<PythonRandomAccessStreamer> m_hack;
            PythonRandomAccessStreamer() {
                // A hack to make this work as PythonRandomAccessStreamer does not return a smart pointer thread New as other POs.
                // Use a custom deleter which doesn't delete to avoid double delete
                m_hack.reset(this, [](PythonRandomAccessStreamer* obj) {});
                mPtr = m_hack;
                setModified(true);
            }

            bool isStopped() {
                return RandomAccessStreamer::isStopped();
            }

            void stop() {
                RandomAccessStreamer::stop();
            }

            void addOutputData(int port, std::shared_ptr<DataObject> image) {
                ProcessObject::addOutputData(port, image);
            }

            DataObject::pointer _getInputData(int port = 0) {
                auto data = ProcessObject::getInputData<DataObject>(port);
                return data;
            }

            DataChannel::pointer getOutputPort(uint portID = 0) {
                return ProcessObject::getOutputPort(portID);
            }

            void createInputPort(int port) {
                ProcessObject::createInputPort<DataObject>(port);
            }
            void createOutputPort(int port) {
                ProcessObject::createOutputPort<DataObject>(port);
            }
            void frameAdded() {
                RandomAccessStreamer::frameAdded();
            }
            int getCurrentFrameIndex() {
                return RandomAccessStreamer::getCurrentFrameIndex();
            }
            int getCurrentFrameIndexAndUpdate() {
                return RandomAccessStreamer::getCurrentFrameIndexAndUpdate();
            }
            bool getPause() {
                return RandomAccessStreamer::getPause();
            }
            void setPause(bool pause) {
                RandomAccessStreamer::setPause(pause);
            }
            void waitForUnpause() {
                return RandomAccessStreamer::waitForUnpause();
            }
            bool getLooping() {
                return RandomAccessStreamer::getLooping();
            }
            void setLooping(bool loop) {
                RandomAccessStreamer::setLooping(loop);
            }
            void setCurrentFrameIndex(int i) {
                RandomAccessStreamer::setCurrentFrameIndex(i);
            }
            int getFramerate() {
                return RandomAccessStreamer::getFramerate();
            }
            void setFramerate(int framerate) {
                RandomAccessStreamer::setFramerate(framerate);
            }
            virtual void stopPipeline() override {
                RandomAccessStreamer::stopPipeline();
            }
        }; // end class python random access streamer
    } // end namespace
%}


%template(createIntBuffer) fast::PythonProcessObject::createBuffer<int>;
%template(createUIntBuffer) fast::PythonProcessObject::createBuffer<uint>;
%template(createCharBuffer) fast::PythonProcessObject::createBuffer<char>;
%template(createUCharBuffer) fast::PythonProcessObject::createBuffer<uchar>;
%template(createShortBuffer) fast::PythonProcessObject::createBuffer<short>;
%template(createUShortBuffer) fast::PythonProcessObject::createBuffer<ushort>;
%template(createFloatBuffer) fast::PythonProcessObject::createBuffer<float>;

// Extend PythonProcessObject with some Python code
%extend fast::PythonProcessObject {
    %pythoncode "@PROJECT_SOURCE_DIR@/source/FAST/Python/ProcessObjectExtensions.py"
}
// Extend PythonStreamer with some Python code
%extend fast::PythonStreamer {
    %pythoncode "@PROJECT_SOURCE_DIR@/source/FAST/Python/ProcessObjectExtensions.py"
}
// Extend PythonRandomAccessStreamer with some Python code
%extend fast::PythonRandomAccessStreamer {
    %pythoncode "@PROJECT_SOURCE_DIR@/source/FAST/Python/ProcessObjectExtensions.py"
}

// Get proper error messages if python error occurs in PythonProcessObject director
// This was taken from https://github.com/swig/swig/issues/1117
%feature("director:except") {
    if($error != NULL) {
        PyObject *exc, *val, *tb;
        PyErr_Fetch(&exc, &val, &tb);
        PyErr_NormalizeException(&exc, &val, &tb);
        std::string err_msg("In method '$symname': ");

        PyObject* exc_str = PyObject_GetAttrString(exc, "__name__");
        err_msg += SWIG_Python_str_AsChar(exc_str);
        Py_XDECREF(exc_str);

        if(val != NULL) {
            PyObject* val_str = PyObject_Str(val);
            err_msg += ": ";
            err_msg += SWIG_Python_str_AsChar(val_str);
            Py_XDECREF(val_str);
        }

        Py_XDECREF(exc);
        Py_XDECREF(val);
        Py_XDECREF(tb);

        Swig::DirectorMethodException::raise(err_msg.c_str());
    }
}

%extend fast::Kernel {
%pythoncode %{
    def setArg(self, id:Union[str, int], data):
        arg = self.getArg(id)
        if not isinstance(data, fast.Image) and not isinstance(data, fast.Tensor) and hasattr(data, '__array_interface__'):
            # NumPy array or similar
            # Make sure it is C contiguous first
            mem = memoryview(data)
            import copy
            array_interface = copy.copy(data.__array_interface__)
            typestr = array_interface['typestr'][1:]
            if typestr not in _str_to_data_type:
                raise TypeError('Unsupported input type given to Kernel.setArg: ' + typestr)
            type = _str_to_data_type[typestr]
            shape = array_interface['shape']
            if mem.c_contiguous:
                data = list(mem.cast('b').cast(mem.format)) # Trick for flattening the data array
            else:
                mem = memoryview(mem.tobytes(order='C')).cast(mem.format) # Convert to C contiguous
                data = list(mem)
        if isinstance(data, fast.Tensor):
            self.setTensorArg(id, data, fast.ACCESS_READ_WRITE)
        elif isinstance(data, fast.OpenCLBuffer):
            self.setBufferArg(id, data)
        elif isinstance(data, list):
            type = ''.join(char for char in arg.type if char.isalpha())
            if type == 'float':
                self.setFloatArgData(id, data)
            elif type == 'int':
                self.setIntArgData(id, data)
            elif type == 'short':
                self.setShortArgData(id, data)
            elif type == 'char':
                self.setCharArgData(id, data)
            elif type == 'uint':
                self.setUIntArgData(id, data)
            elif type == 'ushort':
                self.setUShortArgData(id, data)
            elif type == 'uchar':
                self.setUCharArgData(id, data)
            else:
                raise ValueError('Not able to determine kernel argument type: ' + arg.type + ' in Kernel.setArg. Use the appropriate typed setArg/setArgData function instead, e.g. setFloatArg/setIntArg etc. ')
        else:
            if arg.type == 'float':
                self.setFloatArg(id, data)
            elif arg.type == 'int':
                self.setIntArg(id, data)
            elif arg.type == 'short':
                self.setShortArg(id, data)
            elif arg.type == 'char':
                self.setCharArg(id, data)
            elif arg.type == 'uint':
                self.setUIntArg(id, data)
            elif arg.type == 'ushort':
                self.setUShortArg(id, data)
            elif arg.type == 'uchar':
                self.setUCharArg(id, data)
            elif arg.type == 'image2d_t' or arg.type == 'image3d_t':
                accessMap = {
                    KernelArgumentAccess_READ_ONLY: ACCESS_READ,
                    KernelArgumentAccess_WRITE_ONLY: ACCESS_READ_WRITE,
                    KernelArgumentAccess_READ_WRITE: ACCESS_READ_WRITE,
                }
                self.setImageArg(id, data, accessMap[arg.access])
            else:
                raise ValueError('Not able to determine kernel argument type: ' + arg.type + ' in Kernel.setArg. Use the appropriate typed setArg function instead, e.g. setFloatArg/setIntArg etc. ')
%}
}